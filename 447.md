#CS447

###Patrick Lam
#Lectures 1

**Why Software goes weong**

1. Segfaults / crashes / concurrency issues
2. Wrong API
3. System limitations- resources / perf
4. Improper input sanitization
5. Wrong output / bad specifications

TODO: All of the things above are considered regression

**Dealing with imprested software**

1. Disclaim Liability
2. Patch the Software
3. Defensive Programming (isolate from other parts of the system)re
4. Replicate / backup user data

**Ways of Testing SW**

1. Compile it
2. Run it on one input
3. Run it on many input
4. Run it on a representative set of inputs
5. Run it on all inputs (static analysis)

#Lecture 2
Recall
**Fault:** staticdefect in the code
**Errors:** incorrect internal state
**Failures:** external (observed) incorrect behaviour

**Motivating Example**
In addition, If there is a train on the tract it would be an error

**RIP Fault model**
To get from a fault to a failure:
1. Fault must be reachable
2. Program state after reacing fault must be incorrect: infection
3. Infected state must propagate to output to cause a visible failure

If you have all of these things then we can observe an error in our program

**Dealing with Problems**
avoidance: make it impossibe for people to do the wrong thing (ie avoid buffer overflow) [eg. by choice of programming language]
detection: via testing and verification 
tolerance: redundancy + isolation 

**Testing + debugging**
Testing: must find faults by providing inputs => observe a failture
* Discory of the program and its behaviour
Debugging: have the failure, need the fault => track down the error state
* Fix the fault (Engineering aspect)

---
#Lec 3

(a) Identify the fault, and ﬁx it.
* for loop condition should be i >= 0
(b) If possible, identify a test case that does not execute the fault.
* x = null causese NullPointerException before reaching fault
(c) If possible, identify a test case that executes the fault, but does not result in an error state.
* x = [2,3,5] but y = 3 or 5 
(d) If possible, identify a test case that results in an error, but not a failure. (Hint: program counter)
* look for something not in the array expected = -1 actual = -1
* Error State: in the final iteration,
 * Pc goes to "return 1"
 * instead of "if(x[i] == y)" line
(e) For the given test case, identify the ﬁrst error state. Be sure to describe the complete state
* PC is wrong again,
 * Same as case (d)
 
##Line Intersections

Test suits for intersect
* execute every statement (or every branch) in the method
* feed random inputs to intersect() 
 * unlikely to find the problem here 
* check all outputs of intersect()
 * ONE CASE TRUE, ONE CASE FALSE
* check T/F: a.x1 < b.x2 and a.x2 > b.x1
 * better than checking outputs
* check all "interesting" combinations of inputs
 * exhaustive testing
 
Inputs:
a = a.x1 
b = b.x1
A = a.x2
B = b.x2

* assume all 4 points distinct
 * if not : could have a = A, a = b, a = B
* assume a < b (we can switch when testing
* assime a < A b < B

Cases
* aBbB 
* abAB 
* abBA 

