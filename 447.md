#CS447

###Patrick Lam
#Lectures 1

**Why Software goes wrong**

1. Segfaults / crashes / concurrency issues
2. Wrong API
3. System limitations- resources / perf
4. Improper input sanitization
5. Wrong output / bad specifications

TODO: All of the things above are considered regression

**Dealing with imprested software**

1. Disclaim Liability
2. Patch the Software
3. Defensive Programming (isolate from other parts of the system)re
4. Replicate / backup user data

**Ways of Testing SW**

1. Compile it
2. Run it on one input
3. Run it on many input
4. Run it on a representative set of inputs
5. Run it on all inputs (static analysis)

#Lecture 2
Recall
**Fault:** staticdefect in the code
**Errors:** incorrect internal state
**Failures:** external (observed) incorrect behaviour

**Motivating Example**
In addition, If there is a train on the tract it would be an error

**RIP Fault model**
To get from a fault to a failure:
1. Fault must be reachable
2. Program state after reacing fault must be incorrect: infection
3. Infected state must propagate to output to cause a visible failure

If you have all of these things then we can observe an error in our program

**Dealing with Problems**
avoidance: make it impossibe for people to do the wrong thing (ie avoid buffer overflow) [eg. by choice of programming language]
detection: via testing and verification 
tolerance: redundancy + isolation 

**Testing + debugging**
Testing: must find faults by providing inputs => observe a failture
* Discory of the program and its behaviour
Debugging: have the failure, need the fault => track down the error state
* Fix the fault (Engineering aspect)

---
#Lec 3

(a) Identify the fault, and ﬁx it.
* for loop condition should be i >= 0
(b) If possible, identify a test case that does not execute the fault.
* x = null causese NullPointerException before reaching fault
(c) If possible, identify a test case that executes the fault, but does not result in an error state.
* x = [2,3,5] but y = 3 or 5 
(d) If possible, identify a test case that results in an error, but not a failure. (Hint: program counter)
* look for something not in the array expected = -1 actual = -1
* Error State: in the final iteration,
 * Pc goes to "return 1"
 * instead of "if(x[i] == y)" line
(e) For the given test case, identify the ﬁrst error state. Be sure to describe the complete state
* PC is wrong again,
 * Same as case (d)
 
##Line Intersections

Test suits for intersect
* execute every statement (or every branch) in the method
* feed random inputs to intersect() 
 * unlikely to find the problem here 
* check all outputs of intersect()
 * ONE CASE TRUE, ONE CASE FALSE
* check T/F: a.x1 < b.x2 and a.x2 > b.x1
 * better than checking outputs
* check all "interesting" combinations of inputs
 * exhaustive testing
 
Inputs:
a = a.x1 
b = b.x1
A = a.x2
B = b.x2

* assume all 4 points distinct
 * if not : could have a = A, a = b, a = B
* assume a < b (we can switch when testing
* assime a < A b < B

Cases
* aBbB 
* abAB 
* abBA 

##Lec 4 Todo

##Lec 5

Last Time: Static vs dynamic analysis
* J Unit example
* coverage

This time Exploratory testing

Infeasible Test Requirements:
* TR:  cover every statement in the program
```
if (false)
    unReachableCall() // generates infeasible TR
```

```
while(0)
    { local_irg_disable()} // unreachable code in Linux Kernel    
```

Statements coverage can be infeasible for many programs

*Coverage level* = (Number TRs satisfied by test set T)/Number of TR

Exploratory Testing

"Explatory testing is simultaneous", learning test design and test execution

Explatory testing is good for:
* getting another perspective on the software
* combatting the silos in teh software design
* diversifying testing beyond scripts
* finding bad user experiences/ that most important bug quickly

Exploratory Testing Process
* Start with a goal/charter
 * explore the product elements of the software
* decide which area to test
* design a test  (informally)
* execute the test & kig bugs
* Repeat!

Output: brief notes that allow repro 
* Set of bug reports
* impresions + a summary of testing approach
* artifacts
 * inputs, outputs
 
* WW purpose: *
* Enable employees to post jobs + students to apply to jobs 
* 

*Main Features: *
* Create job postings
* Search for jobs 
* access control + authentication 
* schedule interviews

##Lec 6 
Waterloo works issues
* "accept" box on terms & conditions not visible because can't scroll
* unclear which term to select to see job postion,
* ambiguity in meaning of .... "current term"
* no validation for obviously incorrect term selection
* logout function doesn't actually logout

Overall
* looks nicer then Jobmine
* in 5 minutes, find some issues but no showstoppers
* improvements needed to user experience
* relatively mobile friendly

Control Flow graphs
* an intermediate representation of source code, suitable for analysis

Compilation
.c file sequences of bytes -(lexer eg NFAs)-> sequences of tokens "for"  "while" "strings" "etc"-(parser)-> syntax tree -(compiler / parser)-> control flow graph -> object code

CFG example:
 ```
               -------
               |x = 5|   //a cfg node-
               |z = 2|   // containts statements
               -------
                  |      //CFG edge summarizes permissible control- flow
                  V
               -----------                
               |if(z < 17)|
               -----------                

  |            // If false               |    //if true
  V                               V    
-----------                       |nop|
|z = z+ 1 |
|print (x)| //goes back to if dontions
-----------

```

Low-level code from CFG
```
x = 5
z = 2
q0: if(z < 17) goto q1
z = z+1
print(x)
goto qo
nop
```
Refer to hand out for CFG

##Lec 7

Statement + Branch Coverage (formally)

Definition Given a set of test requests TR for a graph criterion C,

a test set T satisfies C on graph G iff for every test requirenebt tr in TR. (test requirement), at least one test path P in (T) exists such that p satisfies tr 

Tests cases and test paths
* executing a test case t on a program, gives rise to test paths path(t)

Definition: A test path is a path P that starts at an initial node and ends at a final node.
* path(T) = {path(t)| t E T}

Example:
```
int foo(int x){      // ->               [if(x<5)]  (1)
    if(x<5){         //               if F    if T
        x++;         //              [x--] (3)    [x++] (2)
    }else{           //                 [return x] (4)
        x--;
    }
    return x
}
```

```
Test case
x = 7
Test path:
[1,3,4] // note we are missing statement 2
```

```
Test case
x = -3
Test path:
[1,2,4] // note we are missing statement 3
```
